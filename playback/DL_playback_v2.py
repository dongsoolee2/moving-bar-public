# DL_playback_v2(recorded file *.h5, threshold, interval)

# DL_playback_v2 function calculates current to be injected
# to amplify or diminish membrane potential of targeted neuron.
#
# by Dongsoo Lee (created 17-02-23, edited 17-03-15, v2 edited 17-10-18)
# edited: 17-06-30 interleaved 5 * [control + 2 * {amp and dim(a_d) / or (d_a)}]				           
#         17-07-18 set maximum of each trial to 1 (nA) regardless of params
#                  order of lowpass filter(6->4), low cutoff (50(?) -> 15 Hz)
#                  (ref: Pandarinath, 2010 (mice), Robinson, 1997 (cat), Rosa, 2016 (zebrafish)
#                        Kim, 2015 (mice), Moses & Hart (1987))
#         17-10-18 set maximum of each trial to +- 0.7 nA / +- 1.4 nA

import numpy as np
import scipy.signal
import h5py
from pyret.spiketools import peakdet
import matplotlib.pyplot as plt
from scipy.signal import butter, filtfilt, deconvolve


def butter_lowpass(cutoff, fs, order=5):
    nyq = 0.5 * fs
    normal_cutoff = cutoff / nyq
    b_l, a_l = butter(order, normal_cutoff, btype='low', analog=False)
    return b_l, a_l


def butter_lowpass_filter(data, cutoff, fs, order=5):
    b_l, a_l = butter_lowpass(cutoff, fs, order=order)
    y_l = filtfilt(b_l, a_l, data)
    # filtfilt is to compensate delay introduced by this lowpass filter
    return y_l


def butter_highpass(cutoff, fs, order=5):
    nyq = 0.5 * fs
    normal_cutoff = cutoff / nyq
    b_h, a_h = butter(order, normal_cutoff, btype='high', analog=False)
    return b_h, a_h


def butter_highpass_filter(data, cutoff, fs, order=5):
    b_h, a_h = butter_highpass(cutoff, fs, order=order)
    y_h = filtfilt(b_h, a_h, data)
    return y_h


# parameters
# -----------------------------------------------------------
fileName = "/home/dsnl/mb"
fileTag = ".h5"
file_r = fileName + fileTag
threshold = 0.9
# interval = 150  	# one flip is around 167 data points.
tau = 0.017			# Manu & Baccus, 2011
order_l = 4 		# order of the lowpass filter
order_h = 3
cutoff_l = 15		# desired cutoff frequency of the lowpass filter, [Hz]
cutoff_h = 0.04
fs = 10000.0  		# sampling rate, [Hz]
repeat = 4
bar_duration = [2, 2, 2, 2, 2, 2, 2, 2]
sum_dur = sum(bar_duration)
# -----------------------------------------------------------

# Load recording(*.h5) file to detect
f_r = h5py.File(file_r, 'r')
gain = np.double(f_r['data'].attrs['gain'])
# offset = f['data'].attrs['offset']
offset = 0
photodiode = np.double(f_r['data'][0, :]) * gain - offset
max_value = np.max(photodiode)
photodiode_norm = photodiode / max_value

# Find indexes by using pyret.spiketools.peakdet
maxtab, mintab = peakdet(photodiode_norm, threshold)
max_diff = np.diff(maxtab[:, 0])
print(np.diff(maxtab[:, 0]))
# store to consistently synchronize photodiode and injection
start_buffer = np.int(maxtab[:, 0][0])

# Assume that (5) repeats have similar (difference < 5 data points) number
duration = np.int(np.round(np.max(max_diff)))
print(duration)

# Filter signal with highpass filter to compensate fluctuation
voltage_raw = (-np.double(f_r['data'][1, :start_buffer + len(max_diff) * duration + 100]) * gain - offset) * 0.1  # [V]
f_r.close()

# highpass filter
T = np.int(len(voltage_raw) / fs)
t = np.linspace(0, T, len(voltage_raw), endpoint=False)
b_h, a_h = butter_highpass(cutoff_h, fs, order_h)
voltage_raw_hf = butter_highpass_filter(voltage_raw, cutoff_h, fs, order_h)

# average
voltage_chunk = []
for i in range(len(max_diff)):
    voltage_chunk.append(voltage_raw_hf[np.int(maxtab[:, 0][i]):
                                     np.int(maxtab[:, 0][i]) + duration])
voltage_mean = np.mean(np.array(voltage_chunk), axis=0)

# Filter signal with lowpass filter to smooth
# (moving average shows poor performance, so implement butter w/ cutoff=50?)
# Without lowpass filter, the deconvolved signal looks extremely noisy
# when the original signal has high frequency components
# (to produce high frequency signal, current should contain sudden "peaks")
b_l, a_l = butter_lowpass(cutoff_l, fs, order_l)
voltage_mean_lf = butter_lowpass_filter(voltage_mean, cutoff_l, fs, order_l)

# deconvolve with inverted exponential filter to calculate current to be injected
exp_time = np.linspace(0, 0.2, 2000)
exp_filter = np.exp(-exp_time / tau)[0:400]
print("deconvolution start")
recovered, remainder = deconvolve(voltage_mean_lf, exp_filter)
print("deconvolution end")
current_chunk = recovered * np.sum(exp_filter)

# remove noise generated by deconvolution & keep the time consistent
current_chunk_denoise = np.concatenate((np.zeros(500), current_chunk[500:], np.ones(len(exp_filter) - 1) * current_chunk[-1]), axis=0)

# rescale to produce a proper range voltage
# reference: http://www.cns.nyu.edu/~david/handouts/membrane.pdf
# For 40 MOhm, 10 mv (=0.01 V) ~ 0.25 nA (=250 pA)
# For injection, 1(10 * 0.1(H)) = 1 nA
# In short, x [V] * 25 => current to inject [nA]
# 25 is from (1 / membrane_r) [nA]
#current_chunk_scale = current_chunk_denoise * 25  # [nA]
current_chunk_scale = current_chunk_denoise * 25 * 5 # [nA]   # 5 is arbtrary number(usually it's maximum : ~1.3 nA)
ccs = current_chunk_scale
print(np.max(ccs))

# added 17-07-18 (normalize the injecting current; set the maximum to 1 (nA) -> 0.5 (nA)
# changed 17-10-31 (maximum to 0.5/1.0->1.0/1.5 (nA))
ccs_zero = ccs - np.mean(ccs[500:1000])
ccs_norm = []
index_1 = 0
for d in range(len(bar_duration)):
    index_2 = index_1 + np.int((bar_duration[d] / sum_dur) * duration) 
    if np.max(ccs_zero[:]) > -np.min(ccs_zero[:]):
    	ccs_temp = (ccs_zero[index_1:index_2]) / np.max(ccs_zero[index_1:index_2])
    else:
        ccs_temp = (ccs_zero[index_1:index_2]) / -np.min(ccs_zero[index_1:index_2])
    ccs_norm = np.concatenate((ccs_norm, ccs_temp))
    index_1 = index_2
ccs = 0.5 * ccs_norm
ccs[:850] = 0
plt.plot(ccs)
plt.show()

# make a set of [control + 2*(amplify + diminish)]
current_set = np.concatenate((np.zeros(len(ccs)), ccs, -ccs, np.zeros(len(ccs)), ccs, -ccs), axis=0)
#                                                  a     d   			   a     d
# 						   # edited 17-11-03

# Add current sets to make several repeats
current_joined = []
for r in range(repeat):
    current_joined.extend(current_set)
current = np.append(np.zeros(start_buffer), current_joined)
current_ad = current
current_da = -current_ad
current_2ad = 2 * current_ad
current_2da = 2 * current_da
current_nostim = np.append(np.zeros(start_buffer), np.concatenate((ccs, -ccs), axis=0))

# Create a new hdf5 file for injection
analogoutput = "-ao"
amp_dim = "-ad"
dim_amp = "-da"
file_w_ad = fileName + amp_dim + analogoutput + fileTag
file_w_da = fileName + dim_amp + analogoutput + fileTag
amp_dim_2 = "-2ad"
dim_amp_2 = "-2da"
file_w_2ad = fileName + amp_dim_2 + analogoutput + fileTag
file_w_2da = fileName + dim_amp_2 + analogoutput + fileTag
nostim = "-nostim"
file_w_nostim = fileName + nostim + analogoutput + fileTag

# For amp_dim
f_w_ad = h5py.File(file_w_ad, 'w')
dset_ad = f_w_ad.create_dataset('analog-output', (np.size(current),), dtype='double', data=current_ad)
f_w_ad.close()

# For dim_amp
f_w_da = h5py.File(file_w_da, 'w')
dset_da = f_w_da.create_dataset('analog-output', (np.size(current),), dtype='double', data=current_da)
f_w_da.close()

# For 2_amp_dim
f_w_2ad = h5py.File(file_w_2ad, 'w')
dset_2ad = f_w_2ad.create_dataset('analog-output', (np.size(current),), dtype='double', data=current_2ad)
f_w_2ad.close()

# For 2_dim_amp
f_w_2da = h5py.File(file_w_2da, 'w')
dset_2da = f_w_2da.create_dataset('analog-output', (np.size(current),), dtype='double', data=current_2da)
f_w_2da.close()

# For nostim
f_w_nostim = h5py.File(file_w_nostim, 'w')
dset_nostim = f_w_nostim.create_dataset('analog-output', (np.size(current_nostim),), dtype='double', data=current_nostim)
f_w_nostim.close()

#w, h = freqz(b, a, worN=8000)
